diff --git a/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_host.h b/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_host.h
index f96f9de3569ea0ed3427a4510ee5a21f0f39c30b..a45fd5c4f16c2f27581fe98767c10542ec8426bb 100644
--- a/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_host.h
+++ b/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_host.h
@@ -126,6 +126,13 @@ private:
      * @return Returns ERR_OK if called successfully; returns error code otherwise.
      */
     ErrCode HandleGetBundleInfosWithIntFlags(MessageParcel &data, MessageParcel &reply);
+    /**
+     * @brief Handles the GetBundleInfo function called from a IBundleMgr proxy object.
+     * @param data Indicates the data to be read.
+     * @param reply Indicates the reply to be sent;
+     * @return Returns ERR_OK if called successfully; returns error code otherwise.
+     */
+    ErrCode HandleGetBundleInfoWithIntFlagsV9(MessageParcel &data, MessageParcel &reply);
     /**
      * @brief Handles the GetBundleNameForUid function called from a IBundleMgr proxy object.
      * @param data Indicates the data to be read.
diff --git a/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_interface.h b/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_interface.h
index aa07dc056bcf39e79a6132ee0d683d5802bddd9e..ef8d15bb7f220023384540fcaef34a95fc5f05dd 100644
--- a/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_interface.h
+++ b/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_interface.h
@@ -223,6 +223,17 @@ public:
     {
         return false;
     }
+    /**
+     * @brief Obtains BundleInfo of all bundles available in the system.
+     * @param flags Indicates the flag used to specify information contained in the BundleInfo that will be returned.
+     * @param bundleInfos Indicates all of the obtained BundleInfo objects.
+     * @param userId Indicates the user ID.
+     * @return Returns ERR_OK if the BundleInfos is successfully obtained; returns error code otherwise.
+     */
+    virtual ErrCode GetBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos, int32_t userId)
+    {
+        return ERR_APPEXECFWK_SERVICE_INTERNAL_ERROR;
+    }
     /**
      * @brief Obtains the application UID based on the given bundle name and user ID.
      * @param bundleName Indicates the bundle name of the application.
@@ -1175,6 +1186,7 @@ public:
         GET_APPLICATION_INFO_WITH_INT_FLAGS_V9,
         GET_BUNDLE_ARCHIVE_INFO_WITH_INT_FLAGS_V9,
         GET_BUNDLE_INFO_WITH_INT_FLAGS_V9,
+        GET_BUNDLE_INFOS_WITH_INT_FLAGS_V9,
     };
 };
 }  // namespace AppExecFwk
diff --git a/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_proxy.h b/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_proxy.h
index 366ba86b27369fa28c39a871740276820f2e5390..f6a9762933303a1262b3ee22a100febdb6b60992 100644
--- a/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_proxy.h
+++ b/interfaces/inner_api/appexecfwk_core/include/bundlemgr/bundle_mgr_proxy.h
@@ -163,6 +163,14 @@ public:
      */
     virtual bool GetBundleInfos(int32_t flags, std::vector<BundleInfo> &bundleInfos,
         int32_t userId = Constants::UNSPECIFIED_USERID) override;
+    /**
+     * @brief Obtains BundleInfo of all bundles available in the system through the proxy object.
+     * @param flags Indicates the flag used to specify information contained in the BundleInfo that will be returned.
+     * @param bundleInfos Indicates all of the obtained BundleInfo objects.
+     * @param userId Indicates the user ID.
+     * @return Returns ERR_OK if the BundleInfos is successfully obtained; returns error code otherwise.
+     */
+    virtual ErrCode GetBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos, int32_t userId) override;
     /**
      * @brief Obtains the application UID based on the given bundle name and user ID through the proxy object.
      * @param bundleName Indicates the bundle name of the application.
diff --git a/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_host.cpp b/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_host.cpp
index 5dcb50a463a35b74ea7de501bc8da41f342253a6..1d394ad6f1bbb06f90131fd069de75cce98f3d88 100644
--- a/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_host.cpp
+++ b/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_host.cpp
@@ -83,6 +83,8 @@ void BundleMgrHost::init()
     funcMap_.emplace(IBundleMgr::Message::GET_BUNDLE_INFOS, &BundleMgrHost::HandleGetBundleInfos);
     funcMap_.emplace(IBundleMgr::Message::GET_BUNDLE_INFOS_WITH_INT_FLAGS,
         &BundleMgrHost::HandleGetBundleInfosWithIntFlags);
+    funcMap_.emplace(IBundleMgr::Message::GET_BUNDLE_INFOS_WITH_INT_FLAGS_V9,
+        &BundleMgrHost::HandleGetBundleInfosWithIntFlagsV9);
     funcMap_.emplace(IBundleMgr::Message::GET_BUNDLE_NAME_FOR_UID, &BundleMgrHost::HandleGetBundleNameForUid);
     funcMap_.emplace(IBundleMgr::Message::GET_BUNDLES_FOR_UID, &BundleMgrHost::HandleGetBundlesForUid);
     funcMap_.emplace(IBundleMgr::Message::GET_NAME_FOR_UID, &BundleMgrHost::HandleGetNameForUid);
@@ -511,6 +513,28 @@ ErrCode BundleMgrHost::HandleGetBundleInfosWithIntFlags(MessageParcel &data, Mes
     return ERR_OK;
 }
 
+ErrCode BundleMgrHost::HandleGetBundleInfosWithIntFlagsV9(MessageParcel &data, MessageParcel &reply)
+{
+    HITRACE_METER_NAME(HITRACE_TAG_APP, __PRETTY_FUNCTION__);
+    int32_t flags = data.ReadInt32();
+    int32_t userId = data.ReadInt32();
+
+    std::vector<BundleInfo> infos;
+    reply.SetDataCapacity(Constants::MAX_CAPACITY_BUNDLES);
+    auto ret = GetBundleInfosV9(flags, infos, userId);
+    if (!reply.WriteInt32(ret)) {
+        APP_LOGE("write failed");
+        return ERR_APPEXECFWK_PARCEL_ERROR;
+    }
+    if (ret == ERR_OK) {
+        if (!WriteParcelableVectorIntoAshmem(infos, __func__, reply)) {
+            APP_LOGE("write failed");
+            return ERR_APPEXECFWK_PARCEL_ERROR;
+        }
+    }
+    return ERR_OK;
+}
+
 ErrCode BundleMgrHost::HandleGetBundleNameForUid(MessageParcel &data, MessageParcel &reply)
 {
     HITRACE_METER_NAME(HITRACE_TAG_APP, __PRETTY_FUNCTION__);
diff --git a/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_proxy.cpp b/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_proxy.cpp
index 20a028ca2ed36dface683d3370f7823d17d00834..073a5a57f987ea9d987b130f23118fa293c46bbc 100644
--- a/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_proxy.cpp
+++ b/interfaces/inner_api/appexecfwk_core/src/bundlemgr/bundle_mgr_proxy.cpp
@@ -522,6 +522,42 @@ bool BundleMgrProxy::GetBundleInfos(
     return true;
 }
 
+ErrCode BundleMgrProxy::GetBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos, int32_t userId)
+{
+    HITRACE_METER_NAME(HITRACE_TAG_APP, __PRETTY_FUNCTION__);
+    APP_LOGD("begin to get bundle infos");
+    MessageParcel data;
+    if (!data.WriteInterfaceToken(GetDescriptor())) {
+        APP_LOGE("fail to GetBundleInfosV9 due to write InterfaceToken fail");
+        return ERR_APPEXECFWK_PARCEL_ERROR;
+    }
+    if (!data.WriteInt32(flags)) {
+        APP_LOGE("fail to GetBundleInfosV9 due to write flag fail");
+        return ERR_APPEXECFWK_PARCEL_ERROR;
+    }
+    if (!data.WriteInt32(userId)) {
+        APP_LOGE("fail to GetBundleInfosV9 due to write userId fail");
+        return ERR_APPEXECFWK_PARCEL_ERROR;
+    }
+
+    MessageParcel reply;
+    if (!SendTransactCmd(IBundleMgr::Message::GET_BUNDLE_INFOS_WITH_INT_FLAGS_V9, data, reply)) {
+        APP_LOGE("sendTransactCmd failed");
+        return ERR_APPEXECFWK_PARCEL_ERROR;
+    }
+    auto res = reply.ReadInt32();
+    if (res != ERR_OK) {
+        APP_LOGE("host returns error, error code: %{public}d.", res);
+        return res;
+    }
+
+    if (!GetParcelableInfosFromAshmem<BundleInfo>(reply, bundleInfos)) {
+        APP_LOGE("failed to GetBundleInfosV9 from server");
+        return ERR_APPEXECFWK_PARCEL_ERROR;
+    }
+    return ERR_OK;
+}
+
 int BundleMgrProxy::GetUidByBundleName(const std::string &bundleName, const int userId)
 {
     if (bundleName.empty()) {
diff --git a/interfaces/kits/js/bundle_manager/bundle_manager.cpp b/interfaces/kits/js/bundle_manager/bundle_manager.cpp
index ffb8c21961c283c02c47fe23fc41c2d5b4fba892..abbc32f450da4c16e0963fbf4bdcbdbc3606f871 100644
--- a/interfaces/kits/js/bundle_manager/bundle_manager.cpp
+++ b/interfaces/kits/js/bundle_manager/bundle_manager.cpp
@@ -2036,5 +2036,135 @@ napi_value GetPermissionDef(napi_env env, napi_callback_info info)
     callbackPtr.release();
     return promise;
 }
+
+static ErrCode InnerGetBundleInfos(int32_t flags,
+    int32_t userId, std::vector<BundleInfo> &bundleInfos)
+{
+    auto iBundleMgr = CommonFunc::GetBundleMgr();
+    if (iBundleMgr == nullptr) {
+        APP_LOGE("iBundleMgr is null");
+        return ERROR_BUNDLE_SERVICE_EXCEPTION;
+    }
+    ErrCode ret = iBundleMgr->GetBundleInfosV9(flags, bundleInfos, userId);
+    return CommonFunc::ConvertErrCode(ret);
+}
+
+static void ProcessBundleInfos(
+    napi_env env, napi_value result, const std::vector<BundleInfo> &bundleInfos, int32_t flags)
+{
+    if (bundleInfos.size() == 0) {
+        APP_LOGD("bundleInfos is null");
+        return;
+    }
+    size_t index = 0;
+    for (const auto &item : bundleInfos) {
+        APP_LOGD("name{%s}, bundleName{%s} ", item.name.c_str(), item.name.c_str());
+        napi_value objBundleInfo;
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &objBundleInfo));
+        CommonFunc::ConvertBundleInfo(env, item, objBundleInfo, flags);
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, result, index, objBundleInfo));
+        index++;
+    }
+}
+
+void GetBundleInfosComplete(napi_env env, napi_status status, void *data)
+{
+    BundleInfosCallbackInfo *asyncCallbackInfo =
+        reinterpret_cast<BundleInfosCallbackInfo *>(data);
+    if (asyncCallbackInfo == nullptr) {
+        APP_LOGE("asyncCallbackInfo is null in %{public}s", __func__);
+        return;
+    }
+    std::unique_ptr<BundleInfosCallbackInfo> callbackPtr {asyncCallbackInfo};
+    napi_value result[CALLBACK_PARAM_SIZE] = {0};
+    if (asyncCallbackInfo->err == NO_ERROR) {
+        NAPI_CALL_RETURN_VOID(env, napi_get_null(env, &result[0]));
+        NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &result[1]));
+        ProcessBundleInfos(env, result[1], asyncCallbackInfo->bundleInfos, asyncCallbackInfo->flags);
+    } else {
+        result[0] = BusinessError::CreateError(env, asyncCallbackInfo->err, "");
+    }
+    if (asyncCallbackInfo->deferred) {
+        if (asyncCallbackInfo->err == NO_ERROR) {
+            NAPI_CALL_RETURN_VOID(env, napi_resolve_deferred(env, asyncCallbackInfo->deferred, result[1]));
+        } else {
+            NAPI_CALL_RETURN_VOID(env, napi_reject_deferred(env, asyncCallbackInfo->deferred, result[0]));
+        }
+    } else {
+        napi_value callback = nullptr;
+        napi_value placeHolder = nullptr;
+        NAPI_CALL_RETURN_VOID(env, napi_get_reference_value(env, asyncCallbackInfo->callback, &callback));
+        NAPI_CALL_RETURN_VOID(env, napi_call_function(env, nullptr, callback,
+            sizeof(result) / sizeof(result[0]), result, &placeHolder));
+    }
+}
+
+void GetBundleInfosExec(napi_env env, void *data)
+{
+    BundleInfosCallbackInfo *asyncCallbackInfo = reinterpret_cast<BundleInfosCallbackInfo *>(data);
+    if (asyncCallbackInfo == nullptr) {
+        APP_LOGE("asyncCallbackInfo is null in %{public}s", __func__);
+        return;
+    }
+    asyncCallbackInfo->err = InnerGetBundleInfos(asyncCallbackInfo->flags,
+        asyncCallbackInfo->userId, asyncCallbackInfo->bundleInfos);
+}
+
+napi_value GetBundleInfos(napi_env env, napi_callback_info info)
+{
+    APP_LOGD("NAPI_GetBundleInfos called");
+    NapiArg args(env, info);
+    BundleInfosCallbackInfo *asyncCallbackInfo = new (std::nothrow) BundleInfosCallbackInfo(env);
+    if (asyncCallbackInfo == nullptr) {
+        APP_LOGE("asyncCallbackInfo is null.");
+        BusinessError::ThrowError(env, ERROR_OUT_OF_MEMORY_ERROR);
+        return nullptr;
+    }
+    std::unique_ptr<BundleInfosCallbackInfo> callbackPtr {asyncCallbackInfo};
+    if (!args.Init(ARGS_SIZE_ONE, ARGS_SIZE_THREE)) {
+        APP_LOGE("param count invalid.");
+        BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+        return nullptr;
+    }
+    int32_t defaultUserId = IPCSkeleton::GetCallingUid() / Constants::BASE_USER_RANGE;
+    for (size_t i = 0; i < args.GetMaxArgc(); ++i) {
+        napi_valuetype valueType = napi_undefined;
+        napi_typeof(env, args[i], &valueType);
+        if ((i == ARGS_POS_ZERO) && (valueType == napi_number)) {
+            if (!CommonFunc::ParseInt(env, args[i], asyncCallbackInfo->flags)) {
+                APP_LOGE("Falgs %{public}d invalid!", asyncCallbackInfo->flags);
+                BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+            }
+            if (args.GetArgc() == ARGS_SIZE_ONE) {
+                asyncCallbackInfo->userId = defaultUserId;
+            }
+        } else if (i == ARGS_POS_ONE) {
+            if (valueType == napi_number && !CommonFunc::ParseInt(env, args[i], asyncCallbackInfo->userId)) {
+                APP_LOGE("userId %{public}d invalid!", asyncCallbackInfo->userId);
+                BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+
+            } else if (valueType == napi_function) {
+                asyncCallbackInfo->userId = defaultUserId;
+                NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+            } else {
+                APP_LOGE("param check error");
+                BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+                return nullptr;
+            }
+        } else if ((i == ARGS_POS_TWO) && (valueType == napi_function)) {
+            NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+            break;
+        } else {
+            APP_LOGE("param check error");
+            BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+            return nullptr;
+        }
+    }
+    auto promise = CommonFunc::AsyncCallNativeMethod<BundleInfosCallbackInfo>(
+        env, asyncCallbackInfo, "GetBundleInfos", GetBundleInfosExec, GetBundleInfosComplete);
+    callbackPtr.release();
+    APP_LOGD("call NAPI_GetBundleInfos done.");
+    return promise;
+}
 }
 }
\ No newline at end of file
diff --git a/interfaces/kits/js/bundle_manager/bundle_manager.h b/interfaces/kits/js/bundle_manager/bundle_manager.h
index d07c31c86f65d1c80a0c5d004e8f42bdbedbdee5..64980bc64d558953a404dba32b84e5786183b132 100644
--- a/interfaces/kits/js/bundle_manager/bundle_manager.h
+++ b/interfaces/kits/js/bundle_manager/bundle_manager.h
@@ -145,6 +145,14 @@ struct AsyncPermissionDefineCallbackInfo : public BaseCallbackInfo {
     OHOS::AppExecFwk::PermissionDef permissionDef;
 };
 
+struct BundleInfosCallbackInfo : public BaseCallbackInfo {
+    explicit BundleInfosCallbackInfo(napi_env env) : BaseCallbackInfo(env) {}
+
+    int32_t flags = 0;
+    int32_t userId = Constants::UNSPECIFIED_USERID;
+    std::vector<BundleInfo> bundleInfos;
+};
+
 napi_value GetBundleArchiveInfo(napi_env env, napi_callback_info info);
 napi_value GetBundleNameByUid(napi_env env, napi_callback_info info);
 napi_value SetApplicationEnabled(napi_env env, napi_callback_info info);
@@ -163,6 +171,7 @@ napi_value GetProfileByAbility(napi_env env, napi_callback_info info);
 napi_value GetProfileByExAbility(napi_env env, napi_callback_info info);
 napi_value GetApplicationInfo(napi_env env, napi_callback_info info);
 napi_value GetApplicationInfos(napi_env env, napi_callback_info info);
+napi_value GetBundleInfos(napi_env env, napi_callback_info info);
 void CreateApplicationFlagObject(napi_env env, napi_value value);
 void CreateAbilityFlagObject(napi_env env, napi_value value);
 void CreateExtensionAbilityFlagObject(napi_env env, napi_value value);
diff --git a/interfaces/kits/js/bundle_manager/native_module.cpp b/interfaces/kits/js/bundle_manager/native_module.cpp
index 85e0f7f43b41e5f96771dac7f689bf26ac0a45ae..12bddb3a14ec198422355a7a629f4ffb360a7439 100644
--- a/interfaces/kits/js/bundle_manager/native_module.cpp
+++ b/interfaces/kits/js/bundle_manager/native_module.cpp
@@ -57,6 +57,7 @@ static napi_value BundleManagerExport(napi_env env, napi_value exports)
         DECLARE_NAPI_FUNCTION("getProfileByAbility", GetProfileByAbility),
         DECLARE_NAPI_FUNCTION("getProfileByExtensionAbility", GetProfileByExAbility),
         DECLARE_NAPI_FUNCTION("getPermissionDef", GetPermissionDef),
+        DECLARE_NAPI_FUNCTION("getAllBundleInfo", GetBundleInfos),
         DECLARE_NAPI_PROPERTY("AbilityFlag", abilityFlag),
         DECLARE_NAPI_PROPERTY("ExtensionAbilityFlag", extensionFlag),
         DECLARE_NAPI_PROPERTY("ExtensionAbilityType", extensionType),
diff --git a/services/bundlemgr/include/bundle_data_mgr.h b/services/bundlemgr/include/bundle_data_mgr.h
index f78bf5b5eaedc8965b40a0e04af57f53c27cc501..76d330eeec23baecf37635aab9e737efe575292d 100644
--- a/services/bundlemgr/include/bundle_data_mgr.h
+++ b/services/bundlemgr/include/bundle_data_mgr.h
@@ -246,6 +246,14 @@ public:
      */
     bool GetBundleInfos(int32_t flags,
         std::vector<BundleInfo> &bundleInfos, int32_t userId = Constants::UNSPECIFIED_USERID) const;
+    /**
+     * @brief Obtains BundleInfo of all bundles available in the system.
+     * @param flags Indicates the flag used to specify information contained in the BundleInfo that will be returned.
+     * @param bundleInfos Indicates all of the obtained BundleInfo objects.
+     * @param userId Indicates the user ID.
+     * @return Returns ERR_OK if the BundleInfos is successfully obtained; returns error code otherwise.
+     */
+    ErrCode GetBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos, int32_t userId) const;
     /**
      * @brief Obtains the BundleInfo based on a given bundle name.
      * @param bundleName Indicates the application bundle name to be queried.
@@ -819,6 +827,7 @@ private:
     int32_t GetUserIdByUid(int32_t uid) const;
     ErrCode GetInnerBundleInfoByUid(const int uid, InnerBundleInfo &innerBundleInfo) const;
     bool GetAllBundleInfos(int32_t flags, std::vector<BundleInfo> &bundleInfos) const;
+    ErrCode GetAllBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos) const;
     bool ExplicitQueryExtensionInfo(const Want &want, int32_t flags, int32_t userId,
         ExtensionAbilityInfo &extensionInfo, int32_t appIndex = 0) const;
     ErrCode ExplicitQueryExtensionInfoV9(const Want &want, int32_t flags, int32_t userId,
diff --git a/services/bundlemgr/include/bundle_mgr_host_impl.h b/services/bundlemgr/include/bundle_mgr_host_impl.h
index 366ec0e17133ab919e5d065f9a5e9c79ff6c3020..e65c32c354a56275af969a0ec6888d238d76e169 100644
--- a/services/bundlemgr/include/bundle_mgr_host_impl.h
+++ b/services/bundlemgr/include/bundle_mgr_host_impl.h
@@ -171,6 +171,14 @@ public:
      */
     virtual bool GetBundleInfos(int32_t flags,
         std::vector<BundleInfo> &bundleInfos, int32_t userId = Constants::UNSPECIFIED_USERID) override;
+    /**
+     * @brief Obtains BundleInfo of all bundles available in the system.
+     * @param flags Indicates the flag used to specify information contained in the BundleInfo that will be returned.
+     * @param bundleInfos Indicates all of the obtained BundleInfo objects.
+     * @param userId Indicates the user ID.
+     * @return Returns ERR_OK if the BundleInfos is successfully obtained; returns error code otherwise.
+     */
+    virtual ErrCode GetBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos, int32_t userId) override;
     /**
      * @brief Obtains the application UID based on the given bundle name and user ID.
      * @param bundleName Indicates the bundle name of the application.
diff --git a/services/bundlemgr/src/bundle_data_mgr.cpp b/services/bundlemgr/src/bundle_data_mgr.cpp
index 71d55bef536908bee8f5062887544388b8155cac..c1855bf43d34d155e2c6c17f5b1bf557ad8028b9 100644
--- a/services/bundlemgr/src/bundle_data_mgr.cpp
+++ b/services/bundlemgr/src/bundle_data_mgr.cpp
@@ -1491,6 +1491,60 @@ bool BundleDataMgr::GetAllBundleInfos(int32_t flags, std::vector<BundleInfo> &bu
     return find;
 }
 
+ErrCode BundleDataMgr::GetBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos, int32_t userId) const
+{
+    if (userId == Constants::ALL_USERID) {
+        return GetAllBundleInfosV9(flags, bundleInfos);
+    }
+
+    int32_t requestUserId = GetUserId(userId);
+    if (requestUserId == Constants::INVALID_USERID) {
+        return ERR_BUNDLE_MANAGER_PARAM_ERROR;
+    }
+
+    std::lock_guard<std::mutex> lock(bundleInfoMutex_);
+    if (bundleInfos_.empty()) {
+        APP_LOGE("bundleInfos_ data is empty");
+        return ERR_BUNDLE_MANAGER_INTERNAL_ERROR;
+    }
+
+    for (const auto &item : bundleInfos_) {
+        InnerBundleInfo innerBundleInfo;
+        if (GetInnerBundleInfoWithFlagsV9(item.first, flags, innerBundleInfo, requestUserId) != ERR_OK) {
+            continue;
+        }
+
+        BundleInfo bundleInfo;
+        int32_t responseUserId = innerBundleInfo.GetResponseUserId(requestUserId);
+        if (innerBundleInfo.GetBundleInfoV9(flags, bundleInfo, responseUserId) != ERR_OK) {
+            continue;
+        }
+        bundleInfos.emplace_back(bundleInfo);
+    }
+    return ERR_OK;
+}
+
+ErrCode BundleDataMgr::GetAllBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos) const
+{
+    std::lock_guard<std::mutex> lock(bundleInfoMutex_);
+    if (bundleInfos_.empty()) {
+        APP_LOGE("bundleInfos_ data is empty");
+        return ERR_BUNDLE_MANAGER_INTERNAL_ERROR;
+    }
+
+    for (const auto &item : bundleInfos_) {
+        const InnerBundleInfo &info = item.second;
+        if (info.IsDisabled()) {
+            APP_LOGD("app %{public}s is disabled", info.GetBundleName().c_str());
+            continue;
+        }
+        BundleInfo bundleInfo;
+        info.GetBundleInfoV9(flags, bundleInfo, Constants::ALL_USERID);
+        bundleInfos.emplace_back(bundleInfo);
+    }
+    return ERR_OK;
+}
+
 bool BundleDataMgr::GetBundleNameForUid(const int uid, std::string &bundleName) const
 {
     InnerBundleInfo innerBundleInfo;
@@ -1671,7 +1725,7 @@ ErrCode BundleDataMgr::GetAbilityLabel(const std::string &bundleName, const std:
     if (ret != ERR_OK) {
         return ret;
     }
-    
+
     auto ability = innerBundleInfo.FindAbilityInfoV9(bundleName, moduleName, abilityName);
     if (!ability) {
         return ERR_BUNDLE_MANAGER_ABILITY_NOT_EXIST;
diff --git a/services/bundlemgr/src/bundle_mgr_host_impl.cpp b/services/bundlemgr/src/bundle_mgr_host_impl.cpp
index f50a5782157828cc7e0be2cade99a2dc45977c1b..6a0701da78cc0cbecd7103993ddcbbe706ea2281 100644
--- a/services/bundlemgr/src/bundle_mgr_host_impl.cpp
+++ b/services/bundlemgr/src/bundle_mgr_host_impl.cpp
@@ -230,6 +230,22 @@ bool BundleMgrHostImpl::GetBundleInfos(int32_t flags, std::vector<BundleInfo> &b
     return dataMgr->GetBundleInfos(flags, bundleInfos, userId);
 }
 
+ErrCode BundleMgrHostImpl::GetBundleInfosV9(int32_t flags, std::vector<BundleInfo> &bundleInfos, int32_t userId)
+{
+    APP_LOGD("start GetBundleInfosV9, flags : %{public}d, userId : %{public}d", flags, userId);
+    if (!BundlePermissionMgr::VerifyCallingPermission(Constants::PERMISSION_GET_BUNDLE_INFO_PRIVILEGED)) {
+        APP_LOGE("verify permission failed");
+        return ERR_BUNDLE_MANAGER_PERMISSION_DENIED;
+    }
+    APP_LOGD("verify permission success, begin to GetBundleInfosV9");
+    auto dataMgr = GetDataMgrFromService();
+    if (dataMgr == nullptr) {
+        APP_LOGE("DataMgr is nullptr");
+        return ERR_BUNDLE_MANAGER_INTERNAL_ERROR;
+    }
+    return dataMgr->GetBundleInfosV9(flags, bundleInfos, userId);
+}
+
 bool BundleMgrHostImpl::GetBundleNameForUid(const int uid, std::string &bundleName)
 {
     APP_LOGD("start GetBundleNameForUid, uid : %{public}d", uid);
