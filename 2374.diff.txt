diff --git a/interfaces/inner_api/appexecfwk_base/include/hap_module_info.h b/interfaces/inner_api/appexecfwk_base/include/hap_module_info.h
index 0b3e80ae68f627ca11289b8ff7309385625b374c..5daffcc6a579919d23ad914ca4efbbaac5ccfdf5 100644
--- a/interfaces/inner_api/appexecfwk_base/include/hap_module_info.h
+++ b/interfaces/inner_api/appexecfwk_base/include/hap_module_info.h
@@ -86,6 +86,7 @@ struct HapModuleInfo : public Parcelable {
     std::vector<Metadata> metadata;
     int32_t upgradeFlag = 0;
     CompileMode compileMode = CompileMode::JS_BUNDLE;
+    std::string moduleSourceDir;
     bool ReadFromParcel(Parcel &parcel);
     virtual bool Marshalling(Parcel &parcel) const override;
     static HapModuleInfo *Unmarshalling(Parcel &parcel);
diff --git a/interfaces/inner_api/appexecfwk_base/src/hap_module_info.cpp b/interfaces/inner_api/appexecfwk_base/src/hap_module_info.cpp
index 4d499c5952b6a2a3aec9981432b2bb316dd895e2..c3034c25948a6a781e48dbd995824319eea8ffa2 100644
--- a/interfaces/inner_api/appexecfwk_base/src/hap_module_info.cpp
+++ b/interfaces/inner_api/appexecfwk_base/src/hap_module_info.cpp
@@ -65,6 +65,7 @@ const std::string HAP_MODULE_INFO_HQF_INFO = "hqfInfo";
 const std::string HAP_MODULE_INFO_IS_LIB_ISOLATED = "isLibIsolated";
 const std::string HAP_MODULE_INFO_NATIVE_LIBRARY_PATH = "nativeLibraryPath";
 const std::string HAP_MODULE_INFO_CPU_ABI = "cpuAbi";
+const std::string HAP_MODULE_INFO_MODULE_SOURCE_DIR = "moduleSourceDir";
 }
 
 bool HapModuleInfo::ReadFromParcel(Parcel &parcel)
@@ -170,6 +171,7 @@ bool HapModuleInfo::ReadFromParcel(Parcel &parcel)
     isLibIsolated = parcel.ReadBool();
     nativeLibraryPath = Str16ToStr8(parcel.ReadString16());
     cpuAbi = Str16ToStr8(parcel.ReadString16());
+    moduleSourceDir = Str16ToStr8(parcel.ReadString16());
     return true;
 }
 
@@ -260,6 +262,7 @@ bool HapModuleInfo::Marshalling(Parcel &parcel) const
     WRITE_PARCEL_AND_RETURN_FALSE_IF_FAIL(Bool, parcel, isLibIsolated);
     WRITE_PARCEL_AND_RETURN_FALSE_IF_FAIL(String16, parcel, Str8ToStr16(nativeLibraryPath));
     WRITE_PARCEL_AND_RETURN_FALSE_IF_FAIL(String16, parcel, Str8ToStr16(cpuAbi));
+    WRITE_PARCEL_AND_RETURN_FALSE_IF_FAIL(String16, parcel, Str8ToStr16(moduleSourceDir));
     return true;
 }
 
@@ -307,7 +310,8 @@ void to_json(nlohmann::json &jsonObject, const HapModuleInfo &hapModuleInfo)
         {HAP_MODULE_INFO_HQF_INFO, hapModuleInfo.hqfInfo},
         {HAP_MODULE_INFO_IS_LIB_ISOLATED, hapModuleInfo.isLibIsolated},
         {HAP_MODULE_INFO_NATIVE_LIBRARY_PATH, hapModuleInfo.nativeLibraryPath},
-        {HAP_MODULE_INFO_CPU_ABI, hapModuleInfo.cpuAbi}
+        {HAP_MODULE_INFO_CPU_ABI, hapModuleInfo.cpuAbi},
+        {HAP_MODULE_INFO_MODULE_SOURCE_DIR, hapModuleInfo.moduleSourceDir}
     };
 }
 
@@ -651,6 +655,17 @@ void from_json(const nlohmann::json &jsonObject, HapModuleInfo &hapModuleInfo)
         false,
         parseResult,
         ArrayType::NOT_ARRAY);
+    GetValueIfFindKey<std::string>(jsonObject,
+        jsonObjectEnd,
+        HAP_MODULE_INFO_MODULE_SOURCE_DIR,
+        hapModuleInfo.moduleSourceDir,
+        JsonType::STRING,
+        false,
+        parseResult,
+        ArrayType::NOT_ARRAY);
+    if (parseResult != ERR_OK) {
+        APP_LOGW("HapModuleInfo from_json error, error code : %{public}d", parseResult);
+    }
 }
 }  // namespace AppExecFwk
 }  // namespace OHOS
diff --git a/interfaces/kits/js/bundle_manager/bundle_manager.cpp b/interfaces/kits/js/bundle_manager/bundle_manager.cpp
index ffb8c21961c283c02c47fe23fc41c2d5b4fba892..4cecd088c2361e9b09e8a28ddab75585341e41fc 100644
--- a/interfaces/kits/js/bundle_manager/bundle_manager.cpp
+++ b/interfaces/kits/js/bundle_manager/bundle_manager.cpp
@@ -235,7 +235,7 @@ void GetApplicationInfoComplete(napi_env env, napi_status status, void *data)
         return;
     }
     std::unique_ptr<ApplicationInfoCallbackInfo> callbackPtr {asyncCallbackInfo};
-    napi_value result[2] = {0};
+    napi_value result[CALLBACK_PARAM_SIZE] = {0};
     if (asyncCallbackInfo->err == NO_ERROR) {
         NAPI_CALL_RETURN_VOID(env, napi_get_null(env, &result[0]));
         NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &result[1]));
@@ -267,7 +267,7 @@ void GetApplicationInfosComplete(napi_env env, napi_status status, void *data)
         return;
     }
     std::unique_ptr<ApplicationInfosCallbackInfo> callbackPtr {asyncCallbackInfo};
-    napi_value result[2] = {0};
+    napi_value result[CALLBACK_PARAM_SIZE] = {0};
     if (asyncCallbackInfo->err == NO_ERROR) {
         NAPI_CALL_RETURN_VOID(env, napi_get_null(env, &result[0]));
         NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &result[1]));
@@ -365,7 +365,7 @@ napi_value GetApplicationInfo(napi_env env, napi_callback_info info)
         BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
         return nullptr;
     }
-    int defaultUserid = IPCSkeleton::GetCallingUid() / Constants::BASE_USER_RANGE;
+    int defaultUserId = IPCSkeleton::GetCallingUid() / Constants::BASE_USER_RANGE;
     for (size_t i = 0; i < args.GetMaxArgc(); i++) {
         napi_valuetype valueType = napi_undefined;
         napi_typeof(env, args[i], &valueType);
@@ -382,7 +382,7 @@ napi_value GetApplicationInfo(napi_env env, napi_callback_info info)
                     BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
                 }
                 if (args.GetArgc() == ARGS_SIZE_TWO) {
-                    asyncCallbackInfo->userId = defaultUserid;
+                    asyncCallbackInfo->userId = defaultUserId;
                 }
             } else {
                 APP_LOGE("param check error");
@@ -396,15 +396,17 @@ napi_value GetApplicationInfo(napi_env env, napi_callback_info info)
                     BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
                 }
             } else if (valueType == napi_function) {
-                asyncCallbackInfo->userId = defaultUserid;
+                asyncCallbackInfo->userId = defaultUserId;
                 NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
             } else {
                 APP_LOGE("param check error");
                 BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
                 return nullptr;
             }
-        } else if ((i == ARGS_SIZE_THREE) && (valueType == napi_function)) {
-            NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+        } else if (i == ARGS_SIZE_THREE) {
+            if (valueType == napi_function) {
+                NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+            }
             break;
         } else {
             APP_LOGE("param check error");
@@ -435,7 +437,7 @@ napi_value GetApplicationInfos(napi_env env, napi_callback_info info)
         BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
         return nullptr;
     }
-    int32_t defaultUserid = IPCSkeleton::GetCallingUid() / Constants::BASE_USER_RANGE;
+    int32_t defaultUserId = IPCSkeleton::GetCallingUid() / Constants::BASE_USER_RANGE;
     for (size_t i = 0; i < args.GetMaxArgc(); ++i) {
         napi_valuetype valueType = napi_undefined;
         napi_typeof(env, args[i], &valueType);
@@ -445,7 +447,7 @@ napi_value GetApplicationInfos(napi_env env, napi_callback_info info)
                 BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
             }
             if (args.GetArgc() == ARGS_SIZE_ONE) {
-                asyncCallbackInfo->userId = defaultUserid;
+                asyncCallbackInfo->userId = defaultUserId;
             }
         } else if (i == ARGS_POS_ONE) {
             if (valueType == napi_number && !CommonFunc::ParseInt(env, args[i], asyncCallbackInfo->userId)) {
@@ -453,15 +455,17 @@ napi_value GetApplicationInfos(napi_env env, napi_callback_info info)
                 BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
 
             } else if (valueType == napi_function) {
-                asyncCallbackInfo->userId = defaultUserid;
+                asyncCallbackInfo->userId = defaultUserId;
                 NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
             } else {
                 APP_LOGE("param check error");
                 BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
                 return nullptr;
             }
-        } else if ((i == ARGS_POS_TWO) && (valueType == napi_function)) {
-            NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+        } else if (i == ARGS_POS_TWO) {
+            if (valueType == napi_function) {
+                NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+            }
             break;
         } else {
             APP_LOGE("param check error");
@@ -2036,5 +2040,177 @@ napi_value GetPermissionDef(napi_env env, napi_callback_info info)
     callbackPtr.release();
     return promise;
 }
+
+void CreateBundleFlagObject(napi_env env, napi_value value)
+{
+    napi_value nBundleInfoDefault;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_DEFAULT_V9),
+        &nBundleInfoDefault));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_DEFAULT",
+        nBundleInfoDefault));
+
+    napi_value nGetBundleInfoWithApplication;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_WITH_APPLICATION_V9),
+        &nGetBundleInfoWithApplication));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_APPLICATION",
+        nGetBundleInfoWithApplication));
+
+    napi_value nGetBundleInfoWithHapModule;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_WITH_HAP_MODULE_V9),
+        &nGetBundleInfoWithHapModule));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_HAP_MODULE",
+        nGetBundleInfoWithHapModule));
+
+    napi_value nGetBundleInfoWithAbility;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_WITH_ABILITY_V9),
+        &nGetBundleInfoWithAbility));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_ABILITY",
+        nGetBundleInfoWithAbility));
+
+    napi_value nGetBundleInfoWithExtensionAbility;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY_V9),
+        &nGetBundleInfoWithExtensionAbility));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY",
+        nGetBundleInfoWithExtensionAbility));
+
+    napi_value nGetBundleInfoWithRequestedPermission;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(
+        GET_BUNDLE_INFO_WITH_REQUESTED_PERMISSION_V9), &nGetBundleInfoWithRequestedPermission));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_REQUESTED_PERMISSION",
+        nGetBundleInfoWithRequestedPermission));
+
+    napi_value nGetBundleInfoWithMetadata;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_WITH_METADATA_V9),
+        &nGetBundleInfoWithMetadata));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_METADATA",
+        nGetBundleInfoWithMetadata));
+
+    napi_value nGetBundleInfoWithDisable;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_WITH_DISABLE_V9),
+        &nGetBundleInfoWithDisable));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_DISABLE",
+        nGetBundleInfoWithDisable));
+
+    napi_value nGetBundleInfoWithSignatureInfo;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, static_cast<int32_t>(GET_BUNDLE_INFO_WITH_SIGNATURE_INFO_V9),
+        &nGetBundleInfoWithSignatureInfo));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "GET_BUNDLE_INFO_WITH_SIGNATURE_INFO",
+        nGetBundleInfoWithSignatureInfo));
+}
+
+static ErrCode InnerGetBundleInfo(const std::string &bundleName, int32_t flags,
+    int32_t userId, BundleInfo &bundleInfo)
+{
+    auto iBundleMgr = CommonFunc::GetBundleMgr();
+    if (iBundleMgr == nullptr) {
+        APP_LOGE("iBundleMgr is null");
+        return ERROR_BUNDLE_SERVICE_EXCEPTION;
+    }
+    ErrCode ret = iBundleMgr->GetBundleInfoV9(bundleName, flags, bundleInfo, userId);
+    return CommonFunc::ConvertErrCode(ret);
+}
+
+void GetBundleInfoComplete(napi_env env, napi_status status, void *data)
+{
+    BundleInfoCallbackInfo *asyncCallbackInfo =
+        reinterpret_cast<BundleInfoCallbackInfo *>(data);
+    if (asyncCallbackInfo == nullptr) {
+        APP_LOGE("asyncCallbackInfo is null in %{public}s", __func__);
+        return;
+    }
+    std::unique_ptr<BundleInfoCallbackInfo> callbackPtr {asyncCallbackInfo};
+    napi_value result[CALLBACK_PARAM_SIZE] = {0};
+    if (asyncCallbackInfo->err == NO_ERROR) {
+        NAPI_CALL_RETURN_VOID(env, napi_get_null(env, &result[0]));
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &result[1]));
+        CommonFunc::ConvertBundleInfo(env, asyncCallbackInfo->bundleInfo, result[1], asyncCallbackInfo->flags);
+    } else {
+        result[0] = BusinessError::CreateError(env, asyncCallbackInfo->err, "");
+    }
+    if (asyncCallbackInfo->deferred) {
+        if (asyncCallbackInfo->err == NO_ERROR) {
+            NAPI_CALL_RETURN_VOID(env, napi_resolve_deferred(env, asyncCallbackInfo->deferred, result[1]));
+        } else {
+            NAPI_CALL_RETURN_VOID(env, napi_reject_deferred(env, asyncCallbackInfo->deferred, result[0]));
+        }
+    } else {
+        napi_value callback = nullptr;
+        napi_value placeHolder = nullptr;
+        NAPI_CALL_RETURN_VOID(env, napi_get_reference_value(env, asyncCallbackInfo->callback, &callback));
+        NAPI_CALL_RETURN_VOID(env, napi_call_function(env, nullptr, callback,
+            sizeof(result) / sizeof(result[0]), result, &placeHolder));
+    }
+}
+
+void GetBundleInfoExec(napi_env env, void *data)
+{
+    BundleInfoCallbackInfo *asyncCallbackInfo = reinterpret_cast<BundleInfoCallbackInfo *>(data);
+    if (asyncCallbackInfo == nullptr) {
+        APP_LOGE("asyncCallbackInfo is null in %{public}s", __func__);
+        return;
+    }
+    asyncCallbackInfo->err = InnerGetBundleInfo(asyncCallbackInfo->bundleName,
+        asyncCallbackInfo->flags, asyncCallbackInfo->userId, asyncCallbackInfo->bundleInfo);
+}
+
+napi_value GetBundleInfo(napi_env env, napi_callback_info info)
+{
+    APP_LOGD("NAPI_GetBundleInfo called");
+    NapiArg args(env, info);
+    BundleInfoCallbackInfo *asyncCallbackInfo = new (std::nothrow) BundleInfoCallbackInfo(env);
+    if (asyncCallbackInfo == nullptr) {
+        APP_LOGE("asyncCallbackInfo is null.");
+        BusinessError::ThrowError(env, ERROR_OUT_OF_MEMORY_ERROR);
+        return nullptr;
+    }
+    std::unique_ptr<BundleInfoCallbackInfo> callbackPtr {asyncCallbackInfo};
+    if (!args.Init(ARGS_SIZE_TWO, ARGS_SIZE_FOUR)) {
+        APP_LOGE("param count invalid.");
+        BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+        return nullptr;
+    }
+    int defaultUserId = IPCSkeleton::GetCallingUid() / Constants::BASE_USER_RANGE;
+    for (size_t i = 0; i < args.GetMaxArgc(); i++) {
+        napi_valuetype valueType = napi_undefined;
+        napi_typeof(env, args[i], &valueType);
+        if ((i == ARGS_POS_ZERO) && (valueType == napi_string)) {
+            if (!CommonFunc::ParseString(env, args[i], asyncCallbackInfo->bundleName)) {
+                APP_LOGE("appId %{public}s invalid!", asyncCallbackInfo->bundleName.c_str());
+                BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+                return nullptr;
+            }
+        } else if (i == ARGS_SIZE_ONE && valueType == napi_number) {
+            if (!CommonFunc::ParseInt(env, args[i], asyncCallbackInfo->flags)) {
+                APP_LOGE("Falgs %{public}d invalid!", asyncCallbackInfo->flags);
+                BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+            }
+            if (args.GetArgc() == ARGS_SIZE_TWO) {
+                asyncCallbackInfo->userId = defaultUserId;
+            }
+        } else if (i == ARGS_SIZE_TWO && valueType == napi_number) {
+            if (!CommonFunc::ParseInt(env, args[i], asyncCallbackInfo->userId)) {
+                APP_LOGE("userId %{public}d invalid!", asyncCallbackInfo->userId);
+                BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+            }
+        } else if (i == ARGS_SIZE_TWO && valueType == napi_function) {
+            asyncCallbackInfo->userId = defaultUserId;
+            NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+        } else if (i == ARGS_SIZE_THREE) {
+            if (valueType == napi_function) {
+                NAPI_CALL(env, napi_create_reference(env, args[i], NAPI_RETURN_ONE, &asyncCallbackInfo->callback));
+            }
+            break;
+        } else {
+            APP_LOGE("param check error");
+            BusinessError::ThrowError(env, ERROR_PARAM_CHECK_ERROR);
+            return nullptr;
+        }
+    }
+    auto promise = CommonFunc::AsyncCallNativeMethod<BundleInfoCallbackInfo>(
+        env, asyncCallbackInfo, "GetBundleInfo", GetBundleInfoExec, GetBundleInfoComplete);
+    callbackPtr.release();
+    APP_LOGD("call NAPI_GetBundleInfo done.");
+    return promise;
+}
 }
 }
\ No newline at end of file
diff --git a/interfaces/kits/js/bundle_manager/bundle_manager.h b/interfaces/kits/js/bundle_manager/bundle_manager.h
index d07c31c86f65d1c80a0c5d004e8f42bdbedbdee5..c5e20efe031b921f14451036085f5c689f866f73 100644
--- a/interfaces/kits/js/bundle_manager/bundle_manager.h
+++ b/interfaces/kits/js/bundle_manager/bundle_manager.h
@@ -145,6 +145,14 @@ struct AsyncPermissionDefineCallbackInfo : public BaseCallbackInfo {
     OHOS::AppExecFwk::PermissionDef permissionDef;
 };
 
+struct BundleInfoCallbackInfo : public BaseCallbackInfo {
+    explicit BundleInfoCallbackInfo(napi_env env) : BaseCallbackInfo(env) {}
+    std::string bundleName;
+    int32_t flags = 0;
+    int32_t userId = Constants::UNSPECIFIED_USERID;
+    BundleInfo bundleInfo;
+};
+
 napi_value GetBundleArchiveInfo(napi_env env, napi_callback_info info);
 napi_value GetBundleNameByUid(napi_env env, napi_callback_info info);
 napi_value SetApplicationEnabled(napi_env env, napi_callback_info info);
@@ -163,10 +171,12 @@ napi_value GetProfileByAbility(napi_env env, napi_callback_info info);
 napi_value GetProfileByExAbility(napi_env env, napi_callback_info info);
 napi_value GetApplicationInfo(napi_env env, napi_callback_info info);
 napi_value GetApplicationInfos(napi_env env, napi_callback_info info);
+napi_value GetBundleInfo(napi_env env, napi_callback_info info);
 void CreateApplicationFlagObject(napi_env env, napi_value value);
 void CreateAbilityFlagObject(napi_env env, napi_value value);
 void CreateExtensionAbilityFlagObject(napi_env env, napi_value value);
 void CreateExtensionAbilityTypeObject(napi_env env, napi_value value);
+void CreateBundleFlagObject(napi_env env, napi_value value);
 }  // namespace AppExecFwk
 }  // namespace OHOS
 #endif // BUNDLE_FRAMEWORK_INTERFACES_KITS_JS_BUNDLE_MANAGER_BUNDLE_MANAGER_H
diff --git a/interfaces/kits/js/bundle_manager/native_module.cpp b/interfaces/kits/js/bundle_manager/native_module.cpp
index 85e0f7f43b41e5f96771dac7f689bf26ac0a45ae..c3ee0ce12a56049662f0325db9ab44b73d046fd1 100644
--- a/interfaces/kits/js/bundle_manager/native_module.cpp
+++ b/interfaces/kits/js/bundle_manager/native_module.cpp
@@ -41,6 +41,10 @@ static napi_value BundleManagerExport(napi_env env, napi_value exports)
     NAPI_CALL(env, napi_create_object(env, &applicationFlag));
     CreateApplicationFlagObject(env, abilityFlag);
 
+    napi_value bundleFlag = nullptr;
+    NAPI_CALL(env, napi_create_object(env, &bundleFlag));
+    CreateBundleFlagObject(env, bundleFlag);
+
     napi_property_descriptor desc[] = {
         DECLARE_NAPI_FUNCTION("getBundleArchiveInfo", GetBundleArchiveInfo),
         DECLARE_NAPI_FUNCTION("getBundleNameByUid", GetBundleNameByUid),
@@ -57,12 +61,14 @@ static napi_value BundleManagerExport(napi_env env, napi_value exports)
         DECLARE_NAPI_FUNCTION("getProfileByAbility", GetProfileByAbility),
         DECLARE_NAPI_FUNCTION("getProfileByExtensionAbility", GetProfileByExAbility),
         DECLARE_NAPI_FUNCTION("getPermissionDef", GetPermissionDef),
+        DECLARE_NAPI_FUNCTION("getBundleInfo", GetBundleInfo),
         DECLARE_NAPI_PROPERTY("AbilityFlag", abilityFlag),
         DECLARE_NAPI_PROPERTY("ExtensionAbilityFlag", extensionFlag),
         DECLARE_NAPI_PROPERTY("ExtensionAbilityType", extensionType),
         DECLARE_NAPI_FUNCTION("getApplicationInfo", GetApplicationInfo),
         DECLARE_NAPI_FUNCTION("getAllApplicationInfo", GetApplicationInfos),
         DECLARE_NAPI_PROPERTY("ApplicationFlag", applicationFlag),
+        DECLARE_NAPI_PROPERTY("BundleFlag", bundleFlag),
     };
 
     NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
diff --git a/interfaces/kits/js/common/common_func.cpp b/interfaces/kits/js/common/common_func.cpp
index 8e0a0adb931a1ebf64dcc7b07d9dcc1700610647..1c9cc45c2303920115e9c171ce39247aad4c8ce6 100644
--- a/interfaces/kits/js/common/common_func.cpp
+++ b/interfaces/kits/js/common/common_func.cpp
@@ -977,6 +977,240 @@ void CommonFunc::ConvertPermissionDef(napi_env env, napi_value result, const Per
     NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, result, "descriptionId", nDescriptionId));
 }
 
+void CommonFunc::ConvertRequestPermissionUsedScene(napi_env env,
+    const RequestPermissionUsedScene &requestPermissionUsedScene, napi_value result)
+{
+    napi_value nAbilities;
+    NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &nAbilities));
+    for (size_t index = 0; index < requestPermissionUsedScene.abilities.size(); index++) {
+        napi_value objAbility;
+        NAPI_CALL_RETURN_VOID(env,
+            napi_create_string_utf8(env, requestPermissionUsedScene.abilities[index].c_str(),
+                                    NAPI_AUTO_LENGTH, &objAbility));
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, nAbilities, index, objAbility));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, result, "abilities", nAbilities));
+
+    napi_value nWhen;
+    NAPI_CALL_RETURN_VOID(env,
+        napi_create_string_utf8(env, requestPermissionUsedScene.when.c_str(), NAPI_AUTO_LENGTH, &nWhen));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, result, "when", nWhen));
+}
+
+void CommonFunc::ConvertRequestPermission(napi_env env, const RequestPermission &requestPermission, napi_value result)
+{
+    napi_value nPermissionName;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_string_utf8(env, requestPermission.name.c_str(), NAPI_AUTO_LENGTH, &nPermissionName));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, result, NAME, nPermissionName));
+
+    napi_value nReason;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_string_utf8(env, requestPermission.reason.c_str(), NAPI_AUTO_LENGTH, &nReason));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, result, "reason", nReason));
+
+    napi_value nReasonId;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, requestPermission.reasonId, &nReasonId));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, result, "reasonId", nReasonId));
+
+    napi_value nUsedScene;
+    NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &nUsedScene));
+    ConvertRequestPermissionUsedScene(env, requestPermission.usedScene, nUsedScene);
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, result, "usedScene", nUsedScene));
+}
+
+void CommonFunc::ConvertSignatureInfo(napi_env env, const SignatureInfo &signatureInfo, napi_value value)
+{
+    napi_value nAppId;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_string_utf8(env, signatureInfo.appId.c_str(), NAPI_AUTO_LENGTH, &nAppId));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "appId", nAppId));
+
+    napi_value nFingerprint;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_string_utf8(env, signatureInfo.fingerprint.c_str(), NAPI_AUTO_LENGTH, &nFingerprint));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, value, "fingerprint", nFingerprint));
+}
+
+void CommonFunc::ConvertHapModuleInfo(napi_env env, const HapModuleInfo &hapModuleInfo, napi_value objHapModuleInfo)
+{
+    napi_value nName;
+    NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, hapModuleInfo.name.c_str(), NAPI_AUTO_LENGTH, &nName));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, NAME, nName));
+    APP_LOGI("ConvertHapModuleInfo name=%{public}s.", hapModuleInfo.name.c_str());
+
+    napi_value nIcon;
+    NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, hapModuleInfo.iconPath.c_str(), NAPI_AUTO_LENGTH, &nIcon));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, ICON, nIcon));
+
+    napi_value nIconId;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, hapModuleInfo.iconId, &nIconId));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, ICON_ID, nIconId));
+
+    napi_value nLabel;
+    NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, hapModuleInfo.label.c_str(), NAPI_AUTO_LENGTH, &nLabel));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, LABEL, nLabel));
+
+    napi_value nLabelId;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, hapModuleInfo.labelId, &nLabelId));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, LABEL_ID, nLabelId));
+
+    napi_value nDescription;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_string_utf8(env, hapModuleInfo.description.c_str(), NAPI_AUTO_LENGTH, &nDescription));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, DESCRIPTION, nDescription));
+
+    napi_value ndescriptionId;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, hapModuleInfo.descriptionId, &ndescriptionId));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, DESCRIPTION_ID, ndescriptionId));
+
+    napi_value nMainElementName;
+    NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, hapModuleInfo.mainElementName.c_str(), NAPI_AUTO_LENGTH,
+        &nMainElementName));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, "mainElementName", nMainElementName));
+
+    napi_value nAbilityInfos;
+    NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &nAbilityInfos));
+    for (size_t idx = 0; idx < hapModuleInfo.abilityInfos.size(); idx++) {
+        napi_value objAbilityInfo;
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &objAbilityInfo));
+        ConvertAbilityInfo(env, hapModuleInfo.abilityInfos[idx], objAbilityInfo);
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, nAbilityInfos, idx, objAbilityInfo));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, "abilitiesInfo", nAbilityInfos));
+
+    napi_value nExtensionAbilityInfos;
+    napi_create_array_with_length(env, hapModuleInfo.extensionInfos.size(), &nExtensionAbilityInfos);
+    ConvertExtensionInfos(env, hapModuleInfo.extensionInfos, nExtensionAbilityInfos);
+    NAPI_CALL_RETURN_VOID(env,
+        napi_set_named_property(env, objHapModuleInfo, "extensionAbilitiesInfo", nExtensionAbilityInfos));
+
+    napi_value nMetadata;
+    size_t size = hapModuleInfo.metadata.size();
+    NAPI_CALL_RETURN_VOID(env, napi_create_array_with_length(env, size, &nMetadata));
+    for (size_t index = 0; index < size; ++index) {
+        napi_value innerMeta;
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &innerMeta));
+        ConvertMetadata(env, hapModuleInfo.metadata[index], innerMeta);
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, nMetadata, index, innerMeta));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, "metadata", nMetadata));
+
+    napi_value nDeviceTypes;
+    NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &nDeviceTypes));
+    for (size_t idx = 0; idx < hapModuleInfo.deviceTypes.size(); idx++) {
+        napi_value nDeviceType;
+        NAPI_CALL_RETURN_VOID(
+            env, napi_create_string_utf8(env, hapModuleInfo.deviceTypes[idx].c_str(), NAPI_AUTO_LENGTH, &nDeviceType));
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, nDeviceTypes, idx, nDeviceType));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, "deviceTypes", nDeviceTypes));
+
+    napi_value nInstallationFree;
+    NAPI_CALL_RETURN_VOID(env, napi_get_boolean(env, hapModuleInfo.installationFree, &nInstallationFree));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, "installationFree", nInstallationFree));
+
+    napi_value nHashValue;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_string_utf8(env, hapModuleInfo.hashValue.c_str(), NAPI_AUTO_LENGTH, &nHashValue));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, "hashValue", nHashValue));
+
+    napi_value nModuleSourceDir;
+    NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, hapModuleInfo.moduleSourceDir.c_str(), NAPI_AUTO_LENGTH,
+        &nModuleSourceDir));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objHapModuleInfo, "moduleSourceDir", nModuleSourceDir));
+}
+
+void CommonFunc::ConvertBundleInfo(napi_env env, const BundleInfo &bundleInfo, napi_value objBundleInfo, int32_t flags)
+{
+    napi_value nName;
+    NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, bundleInfo.name.c_str(), NAPI_AUTO_LENGTH, &nName));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, NAME, nName));
+
+    napi_value nVendor;
+    NAPI_CALL_RETURN_VOID(env, napi_create_string_utf8(env, bundleInfo.vendor.c_str(), NAPI_AUTO_LENGTH, &nVendor));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "vendor", nVendor));
+
+    napi_value nVersionCode;
+    NAPI_CALL_RETURN_VOID(env, napi_create_uint32(env, bundleInfo.versionCode, &nVersionCode));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "versionCode", nVersionCode));
+
+    napi_value nVersionName;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_string_utf8(env, bundleInfo.versionName.c_str(), NAPI_AUTO_LENGTH, &nVersionName));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "versionName", nVersionName));
+
+    napi_value nMinCompatibleVersionCode;
+    NAPI_CALL_RETURN_VOID(
+        env, napi_create_int32(env, bundleInfo.minCompatibleVersionCode, &nMinCompatibleVersionCode));
+    NAPI_CALL_RETURN_VOID(
+        env, napi_set_named_property(env, objBundleInfo, "minCompatibleVersionCode", nMinCompatibleVersionCode));
+
+    napi_value nTargetVersion;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, bundleInfo.targetVersion, &nTargetVersion));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "targetVersion", nTargetVersion));
+
+    napi_value nAppInfo;
+    if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_APPLICATION_V9)
+        == GET_BUNDLE_INFO_WITH_APPLICATION_V9) {
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &nAppInfo));
+        ConvertApplicationInfo(env, nAppInfo, bundleInfo.applicationInfo);
+    } else {
+        NAPI_CALL_RETURN_VOID(env, napi_get_null(env, &nAppInfo));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "appInfo", nAppInfo));
+
+    napi_value nHapModuleInfos;
+    NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &nHapModuleInfos));
+    for (size_t idx = 0; idx < bundleInfo.hapModuleInfos.size(); idx++) {
+        napi_value objHapModuleInfo;
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &objHapModuleInfo));
+        ConvertHapModuleInfo(env, bundleInfo.hapModuleInfos[idx], objHapModuleInfo);
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, nHapModuleInfos, idx, objHapModuleInfo));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "hapModulesInfo", nHapModuleInfos));
+
+    napi_value nReqPermissionDetails;
+    NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &nReqPermissionDetails));
+    for (size_t idx = 0; idx < bundleInfo.reqPermissionDetails.size(); idx++) {
+        napi_value objReqPermission;
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &objReqPermission));
+        ConvertRequestPermission(env, bundleInfo.reqPermissionDetails[idx], objReqPermission);
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, nReqPermissionDetails, idx, objReqPermission));
+    }
+    NAPI_CALL_RETURN_VOID(
+        env, napi_set_named_property(env, objBundleInfo, "reqPermissionDetails", nReqPermissionDetails));
+
+    napi_value nReqPermissionStates;
+    NAPI_CALL_RETURN_VOID(env, napi_create_array(env, &nReqPermissionStates));
+    for (size_t idx = 0; idx < bundleInfo.reqPermissionStates.size(); idx++) {
+        napi_value nReqPermissionState;
+        NAPI_CALL_RETURN_VOID(env,
+            napi_create_int32(env, static_cast<int32_t>(bundleInfo.reqPermissionStates[idx]), &nReqPermissionState));
+        NAPI_CALL_RETURN_VOID(env, napi_set_element(env, nReqPermissionStates, idx, nReqPermissionState));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "permissionGrantStates",
+        nReqPermissionStates));
+
+    napi_value nSignatureInfo;
+    if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_SIGNATURE_INFO_V9)
+        == GET_BUNDLE_INFO_WITH_SIGNATURE_INFO_V9) {
+        NAPI_CALL_RETURN_VOID(env, napi_create_object(env, &nSignatureInfo));
+        ConvertSignatureInfo(env, bundleInfo.signatureInfo, nSignatureInfo);
+    } else {
+        NAPI_CALL_RETURN_VOID(env, napi_get_null(env, &nSignatureInfo));
+    }
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "signatureInfo", nSignatureInfo));
+
+    napi_value nInstallTime;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int64(env, bundleInfo.installTime, &nInstallTime));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "installTime", nInstallTime));
+
+    napi_value nUpdateTime;
+    NAPI_CALL_RETURN_VOID(env, napi_create_int64(env, bundleInfo.updateTime, &nUpdateTime));
+    NAPI_CALL_RETURN_VOID(env, napi_set_named_property(env, objBundleInfo, "updateTime", nUpdateTime));
+}
+
 void CommonFunc::ConvertBundleChangeInfo(napi_env env, const std::string &bundleName,
     int32_t userId, napi_value bundleChangeInfo)
 {
diff --git a/interfaces/kits/js/common/common_func.h b/interfaces/kits/js/common/common_func.h
index 6208477f8cbef90e30ef8c6f1ca22593f51c5bad..a47ac8c4bf1264c824dfd1020ff50bdd26703410 100644
--- a/interfaces/kits/js/common/common_func.h
+++ b/interfaces/kits/js/common/common_func.h
@@ -94,6 +94,17 @@ static void ConvertApplicationInfo(napi_env env, napi_value objAppInfo, const Ap
 
 static void ConvertPermissionDef(napi_env env, napi_value result, const PermissionDef &permissionDef);
 
+static void ConvertRequestPermission(napi_env env, const RequestPermission &requestPermission, napi_value result);
+
+static void ConvertRequestPermissionUsedScene(napi_env env,
+    const RequestPermissionUsedScene &requestPermissionUsedScene, napi_value result);
+
+static void ConvertSignatureInfo(napi_env env, const SignatureInfo &signatureInfo, napi_value value);
+
+static void ConvertHapModuleInfo(napi_env env, const HapModuleInfo &hapModuleInfo, napi_value objHapModuleInfo);
+
+static void ConvertBundleInfo(napi_env env, const BundleInfo &bundleInfo, napi_value objBundleInfo, int32_t flags);
+
 static void ConvertBundleChangeInfo(napi_env env, const std::string &bundleName,
     int32_t userId, napi_value bundleChangeInfo);
 
diff --git a/services/bundlemgr/include/inner_bundle_info.h b/services/bundlemgr/include/inner_bundle_info.h
index d06cbd5e7ac2ab1bfc2ab49c52a951c6f09c55e1..a9c68d165267c31002ce8754f3745f9dd2f32c8e 100644
--- a/services/bundlemgr/include/inner_bundle_info.h
+++ b/services/bundlemgr/include/inner_bundle_info.h
@@ -1654,6 +1654,9 @@ private:
     void RemoveDuplicateName(std::vector<std::string> &name) const;
     void GetBundleWithReqPermissionsV9(int32_t flags, BundleInfo &bundleInfo) const;
     void ProcessBundleFlags(int32_t flags, int32_t userId, BundleInfo &bundleInfo) const;
+    void ProcessBundleWithHapModuleInfoFlag(int32_t flags, BundleInfo &bundleInfo, int32_t userId) const;
+    void GetBundleWithAbilitiesV9(int32_t flags, HapModuleInfo &hapModuleInfo, int32_t userId) const;
+    void GetBundleWithExtensionAbilitiesV9(int32_t flags, HapModuleInfo &hapModuleInfo) const;
 
     // using for get
     Constants::AppType appType_ = Constants::AppType::THIRD_PARTY_APP;
diff --git a/services/bundlemgr/src/bundle_data_mgr.cpp b/services/bundlemgr/src/bundle_data_mgr.cpp
index 71d55bef536908bee8f5062887544388b8155cac..3895d896315c276ca2cd5e42464528b3303503fd 100644
--- a/services/bundlemgr/src/bundle_data_mgr.cpp
+++ b/services/bundlemgr/src/bundle_data_mgr.cpp
@@ -1323,7 +1323,7 @@ ErrCode BundleDataMgr::GetBundleInfoV9(
     int32_t responseUserId = innerBundleInfo.GetResponseUserId(requestUserId);
     innerBundleInfo.GetBundleInfoV9(flags, bundleInfo, responseUserId);
     APP_LOGD("get bundleInfo(%{public}s) successfully in user(%{public}d)", bundleName.c_str(), userId);
-    return true;
+    return ERR_OK;
 }
 
 ErrCode BundleDataMgr::GetBundlePackInfo(
@@ -1671,7 +1671,7 @@ ErrCode BundleDataMgr::GetAbilityLabel(const std::string &bundleName, const std:
     if (ret != ERR_OK) {
         return ret;
     }
-    
+
     auto ability = innerBundleInfo.FindAbilityInfoV9(bundleName, moduleName, abilityName);
     if (!ability) {
         return ERR_BUNDLE_MANAGER_ABILITY_NOT_EXIST;
diff --git a/services/bundlemgr/src/inner_bundle_info.cpp b/services/bundlemgr/src/inner_bundle_info.cpp
index 11957a302b251321099332c27f76677602a3c670..08a8f95747be48e87b42e37df206acbbd147d528 100644
--- a/services/bundlemgr/src/inner_bundle_info.cpp
+++ b/services/bundlemgr/src/inner_bundle_info.cpp
@@ -2002,18 +2002,6 @@ ErrCode InnerBundleInfo::GetBundleInfoV9(int32_t flags, BundleInfo &bundleInfo,
             if (it == innerModuleInfos_.end()) {
                 APP_LOGE("can not find module %{public}s", info.second.modulePackage.c_str());
             }
-            hapmoduleinfo->hashValue = it->second.hashValue;
-
-            if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_HAP_MODULE_V9)
-                == GET_BUNDLE_INFO_WITH_HAP_MODULE_V9) {
-                bundleInfo.hapModuleInfos.emplace_back(*hapmoduleinfo);
-                if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_METADATA_V9)
-                    != GET_BUNDLE_INFO_WITH_METADATA_V9) {
-                    for (HapModuleInfo &info : bundleInfo.hapModuleInfos) {
-                        info.metadata.clear();
-                    }
-                }
-            }
             bundleInfo.moduleNames.emplace_back(info.second.moduleName);
             bundleInfo.moduleDirs.emplace_back(info.second.modulePath);
             bundleInfo.modulePublicDirs.emplace_back(info.second.moduleDataDir);
@@ -2041,33 +2029,7 @@ void InnerBundleInfo::ProcessBundleFlags(
         }
     }
     GetBundleWithReqPermissionsV9(flags, bundleInfo);
-    if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_ABILITY_V9)
-        == GET_BUNDLE_INFO_WITH_ABILITY_V9) {
-        if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_DISABLE_V9)
-            == GET_BUNDLE_INFO_WITH_DISABLE_V9) {
-            GetBundleWithAbilities(static_cast<uint32_t>(GET_BUNDLE_WITH_ABILITIES) |
-                static_cast<uint32_t>(GET_ABILITY_INFO_WITH_DISABLE), bundleInfo, userId);
-        } else {
-            GetBundleWithAbilities(GET_BUNDLE_WITH_ABILITIES, bundleInfo, userId);
-        }
-        if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_METADATA_V9)
-            != GET_BUNDLE_INFO_WITH_METADATA_V9) {
-            for (AbilityInfo &info : bundleInfo.abilityInfos) {
-                info.metaData.customizeData.clear();
-                info.metadata.clear();
-            }
-        }
-    }
-    if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY_V9)
-        == GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY_V9) {
-        GetBundleWithExtension(GET_BUNDLE_WITH_EXTENSION_INFO, bundleInfo, userId);
-        if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_METADATA_V9)
-            != GET_BUNDLE_INFO_WITH_METADATA_V9) {
-            for (ExtensionAbilityInfo &info : bundleInfo.extensionInfos) {
-                info.metadata.clear();
-            }
-        }
-    }
+    ProcessBundleWithHapModuleInfoFlag(flags, bundleInfo, userId);
     if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_SIGNATURE_INFO_V9)
         == GET_BUNDLE_INFO_WITH_SIGNATURE_INFO_V9) {
         bundleInfo.signatureInfo.appId = bundleInfo.appId;
@@ -2119,6 +2081,84 @@ void InnerBundleInfo::GetModuleWithHashValue(
     hapModuleInfo.hashValue = it->second.hashValue;
 }
 
+void InnerBundleInfo::ProcessBundleWithHapModuleInfoFlag(int32_t flags, BundleInfo &bundleInfo, int32_t userId) const
+{
+    if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_HAP_MODULE_V9)
+        != GET_BUNDLE_INFO_WITH_HAP_MODULE_V9) {
+        bundleInfo.hapModuleInfos.clear();
+        return;
+    }
+    for (const auto &info : innerModuleInfos_) {
+        auto hapmoduleinfo = FindHapModuleInfo(info.second.modulePackage, userId);
+        if (hapmoduleinfo) {
+            auto it = innerModuleInfos_.find(info.second.modulePackage);
+            if (it == innerModuleInfos_.end()) {
+                APP_LOGE("can not find module %{public}s", info.second.modulePackage.c_str());
+            }
+            HapModuleInfo hapModuleInfo = *hapmoduleinfo;
+            hapModuleInfo.hashValue = it->second.hashValue;
+            hapModuleInfo.moduleSourceDir = info.second.modulePath;
+            if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_METADATA_V9)
+                != GET_BUNDLE_INFO_WITH_METADATA_V9) {
+                hapModuleInfo.metadata.clear();
+            }
+
+            GetBundleWithAbilitiesV9(flags, hapModuleInfo, userId);
+            GetBundleWithExtensionAbilitiesV9(flags, hapModuleInfo);
+            bundleInfo.hapModuleInfos.emplace_back(hapModuleInfo);
+        }
+    }
+}
+
+void InnerBundleInfo::GetBundleWithAbilitiesV9(int32_t flags, HapModuleInfo &hapModuleInfo, int32_t userId) const
+{
+    if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_ABILITY_V9)
+        != GET_BUNDLE_INFO_WITH_ABILITY_V9) {
+        hapModuleInfo.abilityInfos.clear();
+        return;
+    }
+    APP_LOGD("Get bundleInfo with abilities.");
+    for (auto &ability : baseAbilityInfos_) {
+        bool isEnabled = IsAbilityEnabled(ability.second, userId);
+        if (!(static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_DISABLE_V9)
+            && !isEnabled) {
+            APP_LOGW("%{public}s is disabled,", ability.second.name.c_str());
+            continue;
+        }
+        AbilityInfo abilityInfo = ability.second;
+        abilityInfo.enabled = isEnabled;
+
+        if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_METADATA_V9)
+            != GET_BUNDLE_INFO_WITH_METADATA_V9) {
+            abilityInfo.metaData.customizeData.clear();
+            abilityInfo.metadata.clear();
+        }
+        hapModuleInfo.abilityInfos.emplace_back(abilityInfo);
+    }
+}
+
+void InnerBundleInfo::GetBundleWithExtensionAbilitiesV9(int32_t flags, HapModuleInfo &hapModuleInfo) const
+{
+    if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY_V9)
+        != GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY_V9) {
+        hapModuleInfo.extensionInfos.clear();
+        return;
+    }
+    APP_LOGD("Get bundleInfo with extensionAbilities.");
+    for (const auto &extensionInfo : baseExtensionInfos_) {
+        if (!extensionInfo.second.enabled) {
+            continue;
+        }
+        ExtensionAbilityInfo info = extensionInfo.second;
+
+        if ((static_cast<uint32_t>(flags) & GET_BUNDLE_INFO_WITH_METADATA_V9)
+            != GET_BUNDLE_INFO_WITH_METADATA_V9) {
+            info.metadata.clear();
+        }
+        hapModuleInfo.extensionInfos.emplace_back(info);
+    }
+}
+
 void InnerBundleInfo::GetBundleWithAbilities(int32_t flags, BundleInfo &bundleInfo, int32_t userId) const
 {
     APP_LOGD("bundleName:%{public}s userid:%{public}d", bundleInfo.name.c_str(), userId);
